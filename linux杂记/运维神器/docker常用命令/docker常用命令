docker run -i -t <image_name/continar_id> /bin/bash  启动容器并启动bash（交互方式）
    -i	--interactive=false以交互模式运行容器，通常与 -t 同时使用；
    -t	--tty=false为容器重新分配一个伪输入终端，通常与 -i 同时使用；
    -d	--detach=false后台运行容器，并返回容器ID；
    -p  --publish=[]映射端口
    -P  --publish-all=false随机端口启动 如果EXPOSE申明了，则会使用把声明的端口全部映射出去
    -d, --detach=false， 指定容器运行于前台还是后台，默认为false
    -u, --user=""， 指定容器的用户
    -a, --attach=[]， 登录容器（必须是以docker run -d启动的容器）
    -w, --workdir=""， 指定容器的工作目录
    -c, --cpu-shares=0， 设置容器CPU权重，在CPU共享场景使用
    -e, --env=[]， 指定环境变量，容器中可以使用该环境变量 Docker run -e "EmailServer=192.168.0.1" myimage
    -m, --memory=""， 指定容器的内存上限
    -P, --publish-all=false， 指定容器暴露的端口
    -p, --publish=[]， 指定容器暴露的端口
    -h, --hostname=""， 指定容器的主机名
    -v, --volume=[]， 给容器挂载存储卷，挂载到容器的某个目录
    --volumes-from=[]， 给容器挂载其他容器上的卷，挂载到容器的某个目录
    --cap-add=[]， 添加权限，权限清单详见：http://linux.die.net/man/7/capabilities
    --cap-drop=[]， 删除权限，权限清单详见：http://linux.die.net/man/7/capabilities
    --cidfile=""， 运行容器后，在指定文件中写入容器PID值，一种典型的监控系统用法
    --cpuset=""， 设置容器可以使用哪些CPU，此参数可以用来容器独占CPU
    --device=[]， 添加主机设备给容器，相当于设备直通
    --dns=[]， 指定容器的dns服务器
    --dns-search=[]， 指定容器的dns搜索域名，写入到容器的/etc/resolv.conf文件
    --entrypoint=""， 覆盖image的入口点
    --env-file=[]， 指定环境变量文件，文件格式为每行一个环境变量
    --expose=[]， 指定容器暴露的端口，即修改镜像的暴露端口
    --link=[]， 指定容器间的关联，使用其他容器的IP、env等信息
    --lxc-conf=[]， 指定容器的配置文件，只有在指定--exec-driver=lxc时使用
    --name=""， 指定容器名字，后续可以通过名字进行容器管理，links特性需要使用名字
    --net="bridge"， 容器网络设置:
        bridge 使用docker daemon指定的网桥
        host //容器使用主机的网络
        container:NAME_or_ID >//使用其他容器的网路，共享IP和PORT等网络资源
        none 容器使用自己的网络（类似--net=bridge），但是不进行配置
    --privileged=false， 指定容器是否为特权容器，特权容器拥有所有的 capabilities
    --restart="no"， 指定容器停止后的重启策略:
        no：容器退出时不重启
        on-failure：容器故障退出（返回值非零）时重启
        always：容器退出时总是重启
    --rm=false， 指定容器停止后自动删除容器(不支持以docker run -d启动的容器)
    --sig-proxy=true， 设置由代理接受并处理信号，但是SIGCHLD、SIGSTOP和SIGKILL不能被代理

docker run -d -it  image_name   启动容器以后台方式运行(更通用的方式）

docker run -d -it --network=host image_name   启动容器以后台方式运行(更通用的方式）使用本机网络、

docker ps   列出当前所有正在运行的container

docker ps -a  列出所有的container

docker ps -l   列出最近一次启动的container

docker images  列出本地所有的镜像

docker rmi imagesID   删除指定的镜像id

docker rm CONTAINER ID   删除指定的CONTAINER id

docker diff 镜像名    查看容器的修改部分

docker kill CONTAINER ID   杀掉正在运行的容器

docker logs 容器ID/name   可以查看到容器主程序的输出

docker pull image_name    下载image

docker push image_name   发布docker镜像

docker version   查看docker版本

docker info   查看docker系统的信息

docker inspect 容器的id 可以查看更详细的关于某一个容器的信息

docker run -d  image-name   后台运行镜像

docker search 镜像名    查找公共的可用镜像

docker stop 容器名/容器 ID      终止运行的容器

docker restart 容器名/容器 ID    重启容器

docker commit  提交，创建个新镜像

docker build -t name:v1.0.0 . 利用 Dockerfile 创建新镜像

docker exec [OPTIONS] CONTAINER COMMAND [ARG...] 进入正在运行的容器 用什么什么交互方式 >>> docker exec -it my-nginx /bin/bash