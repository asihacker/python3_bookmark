第一步解锁内核
第二步 关闭selinux
第三步 关闭防火墙
（不太安全，但是方便）


单进程最大打开文件数限制
ulimit -n 65535

将root启动的单一进程的最大可以打开的文件数设置为65535个。如果系统回显类似于“Operationnotpermitted”之类的话，说明上述限制修改失败，实际上是因为在中指定的数值超过了Linux系统对该用户打开文件数的软限制或硬限制。因此，就需要修改Linux系统对用户的关于打开文件数的软限制和硬限制。
$ vim /etc/security/limits.conf
* soft nofile 65535		//软限制最大文件数
* hard nofile 65535		//硬限制最大文件数
其中’*'号表示修改所有用户的限制；soft或hard指定要修改软限制还是硬限制；65536则指定了想要修改的新的限制值，即最大打开文件数(请注意软限制值要小于或等于硬限制)。修改完后保存文件。

内核TCP参数方面
$ vim /etc/sysctl.conf

net.ipv4.icmp_echo_ignore_broadcasts = 1
#表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；
net.ipv4.tcp_syncookies = 1
#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；
net.ipv4.tcp_tw_reuse = 1
#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭；
net.ipv4.tcp_tw_recycle = 1
#修改系統默认的 TIMEOUT 时间。
net.ipv4.tcp_fin_timeout = 30

#记录的那些尚未收到客户端确认信息的连接请求的最大值。对于有128M内存的系统而言，缺省值是1024，小内存的系统则是128。
net.ipv4.tcp_max_syn_backlog = 65536
#每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目。
net.core.netdev_max_backlog = 32768
#表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟，单位是秒。
net.ipv4.tcp_keepalive_time = 1200
#如果对方不予应答，探测包的发送次数
net.ipv4.tcp_keepalive_probes = 3
#keepalive探测包的发送间隔
net.ipv4.tcp_keepalive_intvl = 15
#放弃回应一个TCP连接请求前﹐需要进行多少次重试。RFC 规定最低的数值是3﹐这也是默认值﹐根据RTO的值大约在3秒 - 8分钟之间。(注意:这个值同时还决定进入的syn连接)
net.ipv4.tcp_retries1 = 3
# 控制内核向已经建立连接的远程主机重新发送数据的次数，低值可以更早的检测到与远程主机失效的连接，因此服务器可以更快的释放该连接，可以修改为5
net.ipv4.tcp_retries2 = 5


#时间戳可以避免序列号的卷绕。一个1Gbps的链路肯定会遇到以前用过的序列号。时间戳能够让内核接受这种“异常”的数据包。这里需要将其关掉。
net.ipv4.tcp_timestsmps = 0

#为了打开对端的连接，内核需要发送一个SYN并附带一个回应前面一个SYN的ACK。也就是所谓三次握手中的第二次握手。这个设置决定了内核放弃连接之前发送SYN+ACK包的数量。
net.ipv4.tcp_synack_retries = 2

#在内核放弃建立连接之前发送SYN包的数量。
net.ipv4.tcp_syn_retries = 2

# 开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接。
net.ipv4.tcp_tw_reuse = 1

net.ipv4.icmp_ignore_bogus_error_responses = 1
# 开启恶意icmp错误消息保护


net.inet.udp.checksum=1
#防止不正确的udp包的攻击

net.ipv4.netfilter.ip_conntrack_max=204800
#设置系统对最大跟踪的TCP连接数的限制


sysctl -p
