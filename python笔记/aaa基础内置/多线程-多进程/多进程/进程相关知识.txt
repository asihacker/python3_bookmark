1.僵尸进程（有害）
    任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，
    等待父进程处理。这是每个子进程在结束时都要经过的阶段。
    如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。
    如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，
    但这并不等于子进程不经过僵尸状态。 如果父进程在子进程结束之前退出，则子进程将由init接管。
    init将会以父进程的身份对僵尸状态的子进程进行处理。
2.孤儿进程(无害)
    孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，
    并由init进程对它们完成状态收集工作。
    孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。
    每当出现一个孤儿进程的时候，
    内核就把孤 儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。
    这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面
    处理它的一切善后工作。因此孤儿进程并不会有什么危害。
3.总结
    严格地来说，僵死进程并不是问题的根源，罪魁祸首是产生出大量僵死进程的那个父进程。
    因此，当我们寻求如何消灭系统中大量的僵死进程时，
    答案就是把产生大 量僵死进程的那个元凶枪毙掉（也就是通过kill发送SIGTERM或者SIGKILL信号啦）。
    枪毙了元凶进程之后，它产生的僵死进程就变成了孤儿进 程，这些孤儿进程会被init进程接管，
    init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源，
    这样，这些已经僵死的孤儿进程 就能瞑目而去了。