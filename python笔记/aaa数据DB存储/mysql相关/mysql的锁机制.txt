https://blog.csdn.net/qq_25827845/article/details/91345678?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162502009516780271520142%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162502009516780271520142&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-91345678.first_rank_v2_pc_rank_v29_1&utm_term=mysql%E4%B8%AD%E9%94%81%E7%9A%84%E6%9C%BA%E5%88%B6&spm=1018.2226.3001.4187
全局锁：
       全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。

    全局锁的典型使用场景是，做全库逻辑备份。也就是把整库每个表都 select 出来存成文本。


表级锁：
        MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。
        表锁：
        表锁的语法是 lock tables … read/write。与 FTWRL 类似，可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。


行锁：
        MySQL 的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如 MyISAM 引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB 是支持行锁的，这也是 MyISAM 被 InnoDB 替代的重要原因之一。

        行级锁包括共享锁、排他锁和更新锁。

共享锁：
        共享锁，简称S锁（Shared Lock）。共享锁锁定的资源可以被其它用户读取，但其它用户不能修改它。在SELECT 命令执行时，通常会对对象进行共享锁锁定。通常加共享锁的数据页被读取完毕后，共享锁就会立即被释放。

排他锁：
        排他锁，也叫独占锁，简称X锁（Exclusive Lock）。独占锁锁定的资源只允许进行锁定操作的程序使用，其它任何对它的操作均不会被接受。执行数据更新命令，即INSERT、UPDATE 或DELETE 命令时，MySQL 会自动使用独占锁。但当对象上有其它锁存在时，无法对其加独占锁。独占锁一直到事务结束才能被释放。

更新锁：
       更新锁是为了防止死锁而设立的。当MySQL准备更新数据时，它首先对数据对象作更新锁锁定，这样数据将不能被修改，但可以读取。等到MySQL确定要进行更新数据操作时，它会自动将更新锁换为独占锁。但当对象上有其它锁存在时，无法对其作更新锁锁定。

注意：
MySQL InnoDB引擎默认的修改数据语句，update,delete,insert都会自动给涉及到的数据加上排他锁，select语句默认不会加任何锁类型，如果加排他锁可以使用select ...for update语句，加共享锁可以使用select ... lock in share mode语句。所以加过排他锁的数据行在其他事务种是不能修改数据的，也不能通过for update和lock in share mode锁的方式查询数据，但可以直接通过select ...from...查询数据，因为普通查询没有任何锁机制。
