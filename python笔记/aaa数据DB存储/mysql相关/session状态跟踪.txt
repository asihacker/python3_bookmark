状态跟踪
一个Session对象从创建到销毁，依次经历四种状态，分别是：

Transient：刚new出来的对象，还不在会话中，也没有保存到数据库。
Pending：transient的对象调用add后，就会变成pending状态，这时会加入sqlalchemy的监管范围，数据并未更新到数据库。
Persistent：该状态表明数据库里已经记录了该对象，在两种情况下对象处于该状态：一是通过flush()方法刷新pending对象，二是从数据库query()得到对象。
Detached：在会话中的事务提交之后，所有的对象都将是Detached状态。
所谓的状态跟踪，就是跟踪以上四个状态，保证数据的准确性并在合理的时机丢弃对象以保证合理开销，那么具体是怎么实现的呢?

我们可以看到，只有在pending状态时，对象的内存数据和数据库中的数据不一致，在Persistent状态时，内存数据和数据库数据已经一致，那么此后任意时刻丢弃该对象数据都是可以的，这时就需要找个合适的时机丢弃对象，过早或过晚都有其缺陷。于是，就让垃圾回收器来做决定，在内存不够的时候释放对象，回收内存。

Session对象采用了弱引用机制，所谓弱引用，就是说，在保存了对象的引用的情况下，对象仍然可能被垃圾回收器回收。在某一时刻通过引用访问对象时，对象可能存在也可能不存在，如果对象不存在，就重新从数据库中加载对象。而如果不希望对象被回收，只需要另外保存一个对象的强引用即可 。