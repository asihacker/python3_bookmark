https://zhuanlan.zhihu.com/p/159457916

1.阻塞I/O模型
    老李去火车站买票，排队三天买到一张退票。
    耗费：在车站吃喝拉撒睡 3天，其他事一件没干。
2.非阻塞I/O模型
    老李去火车站买票，隔12小时去火车站问有没有退票，三天后买到一张票。
    耗费：往返车站6次，路上6小时，其他时间做了好多事。
    和阻塞I/O模型的区别是: 自己轮询
3.I/O复用模型（事件驱动模型）
    select/poll
    老李去火车站买票，委托黄牛，然后每隔6小时电话黄牛询问，黄牛三天内买到票，然后老李去火车站交钱领票。
    耗费：往返车站2次，路上2小时，黄牛手续费100元，打电话17次
    和非阻塞I/O模型的区别是: 委托黄牛
    epoll
    老李去火车站买票，委托黄牛，黄牛买到后即通知老李去领，然后老李去火车站交钱领票。
    耗费：往返车站2次，路上2小时，黄牛手续费100元，无需打电话
    和上面的区别：委托黄牛
    select/poll
    上面说的进程准确的说复用的是select和poll，因为进程也是靠调用select和poll来实现的。

    利用一个函数(select和poll)来监听IO所需的这些数据的状态，一旦IO有数据可以进行读写了，就通知进程就来对这样的IO进行服务（进程收到事件）。

    select的缺点:

    每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大（需要维护一个用来存放大量fd的数据结构，
    这样会使得用户空间和内核空间在传递该结构时复制开销大）
    同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大（对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低）
    select支持的文件描述符数量太小了，默认是1024
    poll的相对select ,没有最大连接数的限制，原因是它是基于链表来存储的。但是缺点也是通过遍历扫描的。也需要用户态拷贝到内核态。

    epoll
    针对上面的缺点，epoll 做了很多优化:

    每次注册新事件 会把所有fd拷贝到内核，不会重复拷贝，保证每个fd，在一个过程中只拷贝一次。
    不是轮询的方式，不会随着fd数目的增加效率下降，epoll 给socket注册回调函数。以回调方式的找到fd。
    epoll对fd的管理采用红黑树（fd的增删）。

    tip1:
    fd 全称是file descriptor,是进程独有的文件描述符表的索引

    tip1: 为什么Nginx的并发性能比apache好
    因为Nginx使用的是epoll，apache使用的是select。

4.信号驱动I/O模型
    老李去火车站买票，给售票员留下电话，有票后，售票员电话通知老李，然后老李去火车站交钱领票。
    耗费：往返车站2次，路上2小时，免黄牛费100元，无需打电话
    和 I/O复用模型的区别是: 电话代替黄牛

5.异步I/O模型
    老李去火车站买票，给售票员留下电话，有票后，售票员电话通知老李并快递送票上门。
    耗费：往返车站1次，路上1小时，免黄牛费100元，无需打电话
    和信号驱动I/O模型的区别是: 电话通知是自取还是送票上门